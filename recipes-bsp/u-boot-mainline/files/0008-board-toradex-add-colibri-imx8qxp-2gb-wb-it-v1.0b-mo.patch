From 52c2bae8472f47c6cb0b9d4877168160e0b7636a Mon Sep 17 00:00:00 2001
From: Marcel Ziswiler <marcel.ziswiler@toradex.com>
Date: Sat, 6 Apr 2019 13:42:24 +0200
Subject: [PATCH 08/19] board: toradex: add colibri imx8qxp 2gb wb it v1.0b
 module support

This commit adds initial support for the Toradex Colibri iMX8QXP 2GB WB
IT V1.0B module. Unlike the V1.0A early access samples exclusively
booting from SD card, they are now strapped to boot from eFuses which
are factory fused to properly boot from their on-module eMMC. U-Boot
supports either booting from the on-module eMMC or may be used for
recovery purpose using the universal update utility (uuu) aka mfgtools
3.0.

Functionality wise the following is known to be working:
- eMMC and MMC/SD card
- Ethernet
- GPIOs
- I2C

Unfortunately, there is no USB functionality for the i.MX 8QXP as of
yet.

Signed-off-by: Marcel Ziswiler <marcel.ziswiler@toradex.com>
Reviewed-by: Igor Opaniuk <igor.opaniuk@toradex.com>

Series-to: u-boot@lists.denx.de
Series-cc: Igor Opaniuk <igor.opaniuk@toradex.com>
Series-cc: Stefano Babic <sbabic@denx.de>
Series-cc: Peng Fan <peng.fan@nxp.com>

Series-version: 6

Series-changes: 2
- Changed imx-atf git clone command to include initial branch
  information as suggested by Igor.
- Sorted board file includes alphabetically as suggested by Igor.
- Got rid of SPL configuration in legacy header file as suggested by
  Igor and the whole use of SPL on i.MX 8X anyway neither works well
  nor makes any much sense at all.

Series-changes: 3
- Added Igor's reviewed-by tag.

Series-changes: 4
- Fixed SPDX as well as using SZ_ macros where applicable as suggested
  by Igor.
- Fixed superfluous trailing line continuation introduced by commit
  0d331c035a09 ("imx: support i.MX8QM MEK board") in the Makefile plus
  sorted stuff alphabetically again.
- Applied changes similar to commit 3b9ac5415084 ("imx: 8qxp_mek: fix
  fdt_file and console"). However, note that using ${baudrate} in
  console= like that won't actually work!
- Applied changes similar to commit e5b8f7e665aa ("imx8qxp: mek: enable
  dm-spl for pm").

Series-changes: 5
- Keep alphabetical order of device trees in Makefile.
- Order targets in Kconfig alphabetically.
- Fix indentation in SPDX.
- Remove stale includes from board file.
- Take into account ahab-container being platform specific.
- Use vidargs instead of multiple discrete video= in configuration.
- Fix console baudrate specification.
- Remove redundant CONFIG_SYS_MMC_ENV_DEV define and add some clarifying
  comment.
- Fix product name being Colibri iMX8X in a comment.
- Remove obsolete CONFIG_NR_DRAM_BANKS.

Series-changes: 6
- Use firmware-imx-8.0 matching NXP's sumo-4.14.78-1.0.0_ga BSP as
  suggested by Max during review of Apalis iMX8QM.
- Drop anyway commented out board_gpio_init() stuff.
- Drop Qualcomm (formwerly Atheros) AR8031 specific board_phy_config()
  stuff not applicable to the Micrel PHY we are using as suggested by
  Max during review of Apalis iMX8QM.

Cover-letter:
colibri imx8qxp 2gb wb it v1.0b module support

This series fixes building for i.MX8 without SPL and adds support for
more lpuart instances, cleans-up and extends the Toradex SKU handling
and last but not least introduces support for the Toradex Colibri
iMX8QXP 2GB WB IT V1.0B module.

This series is available together with the last few clean-up patches
on our git server [1] as well.

[1] http://git.toradex.com/cgit/u-boot-toradex.git/log/?h=for-next
END
---
 arch/arm/dts/Makefile                           |   3 +-
 arch/arm/dts/fsl-imx8qxp-colibri-u-boot.dtsi    | 117 +++++++++
 arch/arm/dts/fsl-imx8qxp-colibri.dts            | 328 ++++++++++++++++++++++++
 arch/arm/mach-imx/imx8/Kconfig                  |  12 +-
 board/toradex/colibri-imx8qxp/Kconfig           |  30 +++
 board/toradex/colibri-imx8qxp/MAINTAINERS       |   9 +
 board/toradex/colibri-imx8qxp/Makefile          |   6 +
 board/toradex/colibri-imx8qxp/README            |  66 +++++
 board/toradex/colibri-imx8qxp/colibri-imx8qxp.c | 160 ++++++++++++
 board/toradex/colibri-imx8qxp/imximage.cfg      |  24 ++
 configs/colibri-imx8qxp_defconfig               |  53 ++++
 include/configs/colibri-imx8qxp.h               | 210 +++++++++++++++
 12 files changed, 1014 insertions(+), 4 deletions(-)
 create mode 100644 arch/arm/dts/fsl-imx8qxp-colibri-u-boot.dtsi
 create mode 100644 arch/arm/dts/fsl-imx8qxp-colibri.dts
 create mode 100644 board/toradex/colibri-imx8qxp/Kconfig
 create mode 100644 board/toradex/colibri-imx8qxp/MAINTAINERS
 create mode 100644 board/toradex/colibri-imx8qxp/Makefile
 create mode 100644 board/toradex/colibri-imx8qxp/README
 create mode 100644 board/toradex/colibri-imx8qxp/colibri-imx8qxp.c
 create mode 100644 board/toradex/colibri-imx8qxp/imximage.cfg
 create mode 100644 configs/colibri-imx8qxp_defconfig
 create mode 100644 include/configs/colibri-imx8qxp.h

diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index e56a39e0b1..598dc213e3 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -576,8 +576,9 @@ dtb-$(CONFIG_MX7) += imx7d-sdb.dtb \
 dtb-$(CONFIG_ARCH_MX7ULP) += imx7ulp-evk.dtb
 
 dtb-$(CONFIG_ARCH_IMX8) += \
-	fsl-imx8qxp-mek.dtb \
 	fsl-imx8qm-mek.dtb \
+	fsl-imx8qxp-colibri.dtb \
+	fsl-imx8qxp-mek.dtb
 
 dtb-$(CONFIG_ARCH_IMX8M) += fsl-imx8mq-evk.dtb
 
diff --git a/arch/arm/dts/fsl-imx8qxp-colibri-u-boot.dtsi b/arch/arm/dts/fsl-imx8qxp-colibri-u-boot.dtsi
new file mode 100644
index 0000000000..5b061f94ba
--- /dev/null
+++ b/arch/arm/dts/fsl-imx8qxp-colibri-u-boot.dtsi
@@ -0,0 +1,117 @@
+// SPDX-License-Identifier: GPL-2.0+ OR X11
+/*
+ * Copyright 2019 Toradex AG
+ */
+
+&{/imx8qx-pm} {
+
+	u-boot,dm-spl;
+};
+
+&mu {
+	u-boot,dm-spl;
+};
+
+&clk {
+	u-boot,dm-spl;
+};
+
+&iomuxc {
+	u-boot,dm-spl;
+};
+
+&pd_lsio {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio0 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio1 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio2 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio3 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio4 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio5 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio6 {
+	u-boot,dm-spl;
+};
+
+&pd_lsio_gpio7 {
+	u-boot,dm-spl;
+};
+
+&pd_conn {
+	u-boot,dm-spl;
+};
+
+&pd_conn_sdch0 {
+	u-boot,dm-spl;
+};
+
+&pd_conn_sdch1 {
+	u-boot,dm-spl;
+};
+
+&pd_conn_sdch2 {
+	u-boot,dm-spl;
+};
+
+&gpio0 {
+	u-boot,dm-spl;
+};
+
+&gpio1 {
+	u-boot,dm-spl;
+};
+
+&gpio2 {
+	u-boot,dm-spl;
+};
+
+&gpio3 {
+	u-boot,dm-spl;
+};
+
+&gpio4 {
+	u-boot,dm-spl;
+};
+
+&gpio5 {
+	u-boot,dm-spl;
+};
+
+&gpio6 {
+	u-boot,dm-spl;
+};
+
+&gpio7 {
+	u-boot,dm-spl;
+};
+
+&lpuart3 {
+	u-boot,dm-spl;
+};
+
+&usdhc1 {
+	u-boot,dm-spl;
+};
+
+&usdhc2 {
+	u-boot,dm-spl;
+};
diff --git a/arch/arm/dts/fsl-imx8qxp-colibri.dts b/arch/arm/dts/fsl-imx8qxp-colibri.dts
new file mode 100644
index 0000000000..0c20edf2cf
--- /dev/null
+++ b/arch/arm/dts/fsl-imx8qxp-colibri.dts
@@ -0,0 +1,328 @@
+// SPDX-License-Identifier: GPL-2.0+ OR X11
+/*
+ * Copyright 2019 Toradex AG
+ */
+
+/dts-v1/;
+
+#include "fsl-imx8qxp.dtsi"
+#include "fsl-imx8qxp-colibri-u-boot.dtsi"
+
+/ {
+	model = "Toradex Colibri iMX8QXP";
+	compatible = "toradex,colibri-imx8qxp", "fsl,imx8qxp";
+
+	chosen {
+		bootargs = "console=ttyLP3,115200 earlycon=lpuart32,0x5a090000,115200";
+		stdout-path = &lpuart3;
+	};
+
+	reg_usbh_vbus: regulator-usbh-vbus {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_usbh1_reg>;
+		regulator-name = "usbh_vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&gpio4 3 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog0>, <&pinctrl_hog1>, <&pinctrl_hog2>;
+
+	colibri-imx8qxp {
+		pinctrl_lpuart0: lpuart0grp {
+			fsl,pins = <
+				SC_P_UART0_RX_ADMA_UART0_RX	0x06000020
+				SC_P_UART0_TX_ADMA_UART0_TX	0x06000020
+			>;
+		};
+
+		pinctrl_lpuart3: lpuart3grp {
+			fsl,pins = <
+				SC_P_FLEXCAN2_RX_ADMA_UART3_RX	0x06000020
+				SC_P_FLEXCAN2_TX_ADMA_UART3_TX	0x06000020
+			>;
+		};
+
+		pinctrl_lpuart3_ctrl: lpuart3ctrlgrp {
+			fsl,pins = <
+				SC_P_MIPI_DSI1_GPIO0_01_LSIO_GPIO2_IO00 0x00000020 /* DTR */
+				SC_P_SAI1_RXD_LSIO_GPIO0_IO29		0x00000020 /* CTS */
+				SC_P_SAI1_RXC_LSIO_GPIO0_IO30		0x00000020 /* RTS */
+				SC_P_CSI_RESET_LSIO_GPIO3_IO03		0x00000020 /* DSR */
+				SC_P_USDHC1_CD_B_LSIO_GPIO4_IO22	0x00000020 /* DCD */
+				SC_P_CSI_EN_LSIO_GPIO3_IO02		0x00000020 /* RI */
+			>;
+		};
+
+		pinctrl_fec1: fec1grp {
+			fsl,pins = <
+				SC_P_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB0_PAD	0x000014a0 /* Use pads in 3.3V mode */
+				SC_P_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB1_PAD	0x000014a0 /* Use pads in 3.3V mode */
+				SC_P_ENET0_MDC_CONN_ENET0_MDC			0x06000020
+				SC_P_ENET0_MDIO_CONN_ENET0_MDIO			0x06000020
+				SC_P_ENET0_RGMII_TX_CTL_CONN_ENET0_RGMII_TX_CTL	0x00000061
+				SC_P_ENET0_RGMII_TXC_CONN_ENET0_RCLK50M_OUT	0x06000061
+				SC_P_ENET0_RGMII_TXD0_CONN_ENET0_RGMII_TXD0	0x00000061
+				SC_P_ENET0_RGMII_TXD1_CONN_ENET0_RGMII_TXD1	0x00000061
+				SC_P_ENET0_RGMII_RX_CTL_CONN_ENET0_RGMII_RX_CTL	0x00000061
+				SC_P_ENET0_RGMII_RXD0_CONN_ENET0_RGMII_RXD0	0x00000061
+				SC_P_ENET0_RGMII_RXD1_CONN_ENET0_RGMII_RXD1	0x00000061
+				SC_P_ENET0_RGMII_RXD2_CONN_ENET0_RMII_RX_ER	0x00000061
+			>;
+		};
+
+		pinctrl_gpio_bl_on: gpio-bl-on {
+			fsl,pins = <
+				SC_P_QSPI0A_DATA3_LSIO_GPIO3_IO12	0x00000040
+			>;
+		};
+
+		pinctrl_hog0: hog0grp {
+			fsl,pins = <
+				SC_P_COMP_CTL_GPIO_1V8_3V3_GPIORHB_PAD	0x000514a0 /* Use pads in 3.3V mode */
+			>;
+		};
+
+		pinctrl_hog1: hog1grp {
+			fsl,pins = <
+				SC_P_QSPI0A_DATA1_LSIO_GPIO3_IO10	0x00000020 /*  45 */
+				SC_P_ENET0_RGMII_TXD3_LSIO_GPIO5_IO02	0x06000020 /*  65 */
+					SC_P_CSI_D07_CI_PI_D09		0x00000061
+				SC_P_QSPI0A_DATA2_LSIO_GPIO3_IO11	0x00000020 /*  69 */
+				SC_P_QSPI0A_DQS_LSIO_GPIO3_IO13		0x00000020 /*  73 */
+				SC_P_SAI0_TXC_LSIO_GPIO0_IO26		0x00000020 /*  79 */
+					SC_P_CSI_D02_CI_PI_D04		0x00000061
+				SC_P_ENET0_RGMII_RXC_LSIO_GPIO5_IO03	0x06000020 /*  85 */
+					SC_P_CSI_D06_CI_PI_D08		0x00000061
+				SC_P_QSPI0B_SCLK_LSIO_GPIO3_IO17	0x00000020 /*  95 */
+				SC_P_SAI0_RXD_LSIO_GPIO0_IO27		0x00000020 /*  97 */
+					SC_P_CSI_D03_CI_PI_D05		0x00000061
+				SC_P_QSPI0B_DATA0_LSIO_GPIO3_IO18	0x00000020 /*  99 */
+				SC_P_SAI0_TXFS_LSIO_GPIO0_IO28		0x00000020 /* 101 */
+					SC_P_CSI_D00_CI_PI_D02		0x00000061
+				SC_P_SAI0_TXD_LSIO_GPIO0_IO25		0x00000020 /* 103 */
+					SC_P_CSI_D01_CI_PI_D03		0x00000061
+				SC_P_QSPI0B_DATA1_LSIO_GPIO3_IO19	0x00000020 /* 105 */
+				SC_P_QSPI0B_DATA2_LSIO_GPIO3_IO20	0x00000020 /* 107 */
+				SC_P_USB_SS3_TC2_LSIO_GPIO4_IO05	0x00000020 /* 127 */
+				SC_P_USB_SS3_TC3_LSIO_GPIO4_IO06	0x00000020 /* 131 */
+				SC_P_USB_SS3_TC1_LSIO_GPIO4_IO04	0x00000020 /* 133 */
+				SC_P_CSI_PCLK_LSIO_GPIO3_IO00		0x00000020 /*  96 */
+				SC_P_QSPI0B_DATA3_LSIO_GPIO3_IO21	0x00000020 /*  98 */
+				SC_P_SAI1_RXFS_LSIO_GPIO0_IO31		0x00000020 /* 100 */
+				SC_P_QSPI0B_DQS_LSIO_GPIO3_IO22		0x00000020 /* 102 */
+				SC_P_QSPI0B_SS0_B_LSIO_GPIO3_IO23	0x00000020 /* 104 */
+				SC_P_QSPI0B_SS1_B_LSIO_GPIO3_IO24	0x00000020 /* 106 */
+			>;
+		};
+
+		pinctrl_hog2: hog2grp {
+			fsl,pins = <
+				SC_P_CSI_MCLK_LSIO_GPIO3_IO01		0x00000020 /*  75 */
+				SC_P_QSPI0A_SS0_B_LSIO_GPIO3_IO14	0x00000020 /*  77 */
+				SC_P_QSPI0A_SS1_B_LSIO_GPIO3_IO15	0x00000020 /*  89 */
+				SC_P_QSPI0A_SCLK_LSIO_GPIO3_IO16	0x00000020 /*  93 */
+			>;
+		};
+
+		/* Off Module I2C */
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				SC_P_MIPI_DSI0_GPIO0_00_ADMA_I2C1_SCL	0x06000021
+				SC_P_MIPI_DSI0_GPIO0_01_ADMA_I2C1_SDA	0x06000021
+			>;
+		};
+
+		/*INT*/
+		pinctrl_usb3503a: usb3503a-grp {
+			fsl,pins = <
+				SC_P_MIPI_CSI0_MCLK_OUT_LSIO_GPIO3_IO04 0x00000061
+			>;
+		};
+
+		pinctrl_usbc_det: usbc-det {
+			fsl,pins = <
+				SC_P_ENET0_REFCLK_125M_25M_LSIO_GPIO5_IO09	0x06000040
+			>;
+		};
+
+		pinctrl_usbh1_reg: usbh1-reg {
+			fsl,pins = <
+				SC_P_USB_SS3_TC0_LSIO_GPIO4_IO03	0x06000040
+			>;
+		};
+
+		pinctrl_usdhc1: usdhc1grp {
+			fsl,pins = <
+				SC_P_EMMC0_CLK_CONN_EMMC0_CLK		0x06000041
+				SC_P_EMMC0_CMD_CONN_EMMC0_CMD		0x00000021
+				SC_P_EMMC0_DATA0_CONN_EMMC0_DATA0	0x00000021
+				SC_P_EMMC0_DATA1_CONN_EMMC0_DATA1	0x00000021
+				SC_P_EMMC0_DATA2_CONN_EMMC0_DATA2	0x00000021
+				SC_P_EMMC0_DATA3_CONN_EMMC0_DATA3	0x00000021
+				SC_P_EMMC0_DATA4_CONN_EMMC0_DATA4	0x00000021
+				SC_P_EMMC0_DATA5_CONN_EMMC0_DATA5	0x00000021
+				SC_P_EMMC0_DATA6_CONN_EMMC0_DATA6	0x00000021
+				SC_P_EMMC0_DATA7_CONN_EMMC0_DATA7	0x00000021
+				SC_P_EMMC0_STROBE_CONN_EMMC0_STROBE	0x00000041
+				SC_P_EMMC0_RESET_B_CONN_EMMC0_RESET_B	0x00000021
+			>;
+		};
+
+		pinctrl_usdhc1_100mhz: usdhc1grp100mhz {
+			fsl,pins = <
+				SC_P_EMMC0_CLK_CONN_EMMC0_CLK		0x06000041
+				SC_P_EMMC0_CMD_CONN_EMMC0_CMD		0x00000021
+				SC_P_EMMC0_DATA0_CONN_EMMC0_DATA0	0x00000021
+				SC_P_EMMC0_DATA1_CONN_EMMC0_DATA1	0x00000021
+				SC_P_EMMC0_DATA2_CONN_EMMC0_DATA2	0x00000021
+				SC_P_EMMC0_DATA3_CONN_EMMC0_DATA3	0x00000021
+				SC_P_EMMC0_DATA4_CONN_EMMC0_DATA4	0x00000021
+				SC_P_EMMC0_DATA5_CONN_EMMC0_DATA5	0x00000021
+				SC_P_EMMC0_DATA6_CONN_EMMC0_DATA6	0x00000021
+				SC_P_EMMC0_DATA7_CONN_EMMC0_DATA7	0x00000021
+				SC_P_EMMC0_STROBE_CONN_EMMC0_STROBE	0x00000041
+				SC_P_EMMC0_RESET_B_CONN_EMMC0_RESET_B	0x00000021
+			>;
+		};
+
+		pinctrl_usdhc1_200mhz: usdhc1grp200mhz {
+			fsl,pins = <
+				SC_P_EMMC0_CLK_CONN_EMMC0_CLK		0x06000041
+				SC_P_EMMC0_CMD_CONN_EMMC0_CMD		0x00000021
+				SC_P_EMMC0_DATA0_CONN_EMMC0_DATA0	0x00000021
+				SC_P_EMMC0_DATA1_CONN_EMMC0_DATA1	0x00000021
+				SC_P_EMMC0_DATA2_CONN_EMMC0_DATA2	0x00000021
+				SC_P_EMMC0_DATA3_CONN_EMMC0_DATA3	0x00000021
+				SC_P_EMMC0_DATA4_CONN_EMMC0_DATA4	0x00000021
+				SC_P_EMMC0_DATA5_CONN_EMMC0_DATA5	0x00000021
+				SC_P_EMMC0_DATA6_CONN_EMMC0_DATA6	0x00000021
+				SC_P_EMMC0_DATA7_CONN_EMMC0_DATA7	0x00000021
+				SC_P_EMMC0_STROBE_CONN_EMMC0_STROBE	0x00000041
+				SC_P_EMMC0_RESET_B_CONN_EMMC0_RESET_B	0x00000021
+			>;
+		};
+
+		pinctrl_usdhc2_gpio: usdhc2gpiogrp {
+			fsl,pins = <
+				SC_P_QSPI0A_DATA0_LSIO_GPIO3_IO09	0x06000021
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				SC_P_USDHC1_CLK_CONN_USDHC1_CLK		0x06000041
+				SC_P_USDHC1_CMD_CONN_USDHC1_CMD		0x00000021
+				SC_P_USDHC1_DATA0_CONN_USDHC1_DATA0	0x00000021
+				SC_P_USDHC1_DATA1_CONN_USDHC1_DATA1	0x00000021
+				SC_P_USDHC1_DATA2_CONN_USDHC1_DATA2	0x00000021
+				SC_P_USDHC1_DATA3_CONN_USDHC1_DATA3	0x00000021
+				SC_P_USDHC1_VSELECT_CONN_USDHC1_VSELECT	0x00000021
+			>;
+		};
+
+		pinctrl_usdhc2_100mhz: usdhc2grp100mhz {
+			fsl,pins = <
+				SC_P_USDHC1_CLK_CONN_USDHC1_CLK		0x06000041
+				SC_P_USDHC1_CMD_CONN_USDHC1_CMD		0x00000021
+				SC_P_USDHC1_DATA0_CONN_USDHC1_DATA0	0x00000021
+				SC_P_USDHC1_DATA1_CONN_USDHC1_DATA1	0x00000021
+				SC_P_USDHC1_DATA2_CONN_USDHC1_DATA2	0x00000021
+				SC_P_USDHC1_DATA3_CONN_USDHC1_DATA3	0x00000021
+				SC_P_USDHC1_VSELECT_CONN_USDHC1_VSELECT	0x00000021
+			>;
+		};
+
+		pinctrl_usdhc2_200mhz: usdhc2grp200mhz {
+			fsl,pins = <
+				SC_P_USDHC1_CLK_CONN_USDHC1_CLK		0x06000041
+				SC_P_USDHC1_CMD_CONN_USDHC1_CMD		0x00000021
+				SC_P_USDHC1_DATA0_CONN_USDHC1_DATA0	0x00000021
+				SC_P_USDHC1_DATA1_CONN_USDHC1_DATA1	0x00000021
+				SC_P_USDHC1_DATA2_CONN_USDHC1_DATA2	0x00000021
+				SC_P_USDHC1_DATA3_CONN_USDHC1_DATA3	0x00000021
+				SC_P_USDHC1_VSELECT_CONN_USDHC1_VSELECT	0x00000021
+			>;
+		};
+	};
+};
+
+&lpuart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lpuart0>;
+	status = "okay";
+};
+
+&lpuart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lpuart3>, <&pinctrl_lpuart3_ctrl>;
+	status = "okay";
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio3 {
+	status = "okay";
+};
+
+&gpio4 {
+	status = "okay";
+};
+
+&fec1 {
+	phy-handle = <&ethphy0>;
+	phy-mode = "rmii";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec1>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@2 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			max-speed = <100>;
+			reg = <2>;
+		};
+	};
+};
+
+&i2c1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+};
+
+&usdhc1 {
+	bus-width = <8>;
+	non-removable;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>;
+	status = "okay";
+};
+
+&usdhc2 {
+	bus-width = <4>;
+	cd-gpios = <&gpio3 9 GPIO_ACTIVE_LOW>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+	status = "okay";
+};
diff --git a/arch/arm/mach-imx/imx8/Kconfig b/arch/arm/mach-imx/imx8/Kconfig
index c32f7dbb61..90223aaefc 100644
--- a/arch/arm/mach-imx/imx8/Kconfig
+++ b/arch/arm/mach-imx/imx8/Kconfig
@@ -27,8 +27,8 @@ choice
 	prompt "i.MX8 board select"
 	optional
 
-config TARGET_IMX8QXP_MEK
-	bool "Support i.MX8QXP MEK board"
+config TARGET_COLIBRI_IMX8QXP
+	bool "Support Colibri iMX8QXP module"
 	select BOARD_LATE_INIT
 	select IMX8QXP
 
@@ -37,9 +37,15 @@ config TARGET_IMX8QM_MEK
 	select BOARD_LATE_INIT
 	select IMX8QM
 
+config TARGET_IMX8QXP_MEK
+	bool "Support i.MX8QXP MEK board"
+	select BOARD_LATE_INIT
+	select IMX8QXP
+
 endchoice
 
-source "board/freescale/imx8qxp_mek/Kconfig"
 source "board/freescale/imx8qm_mek/Kconfig"
+source "board/freescale/imx8qxp_mek/Kconfig"
+source "board/toradex/colibri-imx8qxp/Kconfig"
 
 endif
diff --git a/board/toradex/colibri-imx8qxp/Kconfig b/board/toradex/colibri-imx8qxp/Kconfig
new file mode 100644
index 0000000000..340fe72816
--- /dev/null
+++ b/board/toradex/colibri-imx8qxp/Kconfig
@@ -0,0 +1,30 @@
+if TARGET_COLIBRI_IMX8QXP
+
+config SYS_BOARD
+	default "colibri-imx8qxp"
+
+config SYS_VENDOR
+	default "toradex"
+
+config SYS_CONFIG_NAME
+	default "colibri-imx8qxp"
+
+config TDX_CFG_BLOCK
+	default y
+
+config TDX_HAVE_MMC
+	default y
+
+config TDX_CFG_BLOCK_DEV
+	default "0"
+
+config TDX_CFG_BLOCK_PART
+	default "1"
+
+# Toradex config block in eMMC, at the end of 1st "boot sector"
+config TDX_CFG_BLOCK_OFFSET
+	default "-512"
+
+source "board/toradex/common/Kconfig"
+
+endif
diff --git a/board/toradex/colibri-imx8qxp/MAINTAINERS b/board/toradex/colibri-imx8qxp/MAINTAINERS
new file mode 100644
index 0000000000..39a9eb79b7
--- /dev/null
+++ b/board/toradex/colibri-imx8qxp/MAINTAINERS
@@ -0,0 +1,9 @@
+Colibri iMX8QXP
+M:	Marcel Ziswiler <marcel.ziswiler@toradex.com>
+W:	http://developer.toradex.com/software/linux/linux-software
+S:	Maintained
+F:	arch/arm/dts/fsl-imx8qxp-colibri.dts
+F:	arch/arm/dts/fsl-imx8qxp-colibri-u-boot.dtsi
+F:	board/toradex/colibri-imx8qxp/
+F:	configs/colibri-imx8qxp_defconfig
+F:	include/configs/colibri-imx8qxp.h
diff --git a/board/toradex/colibri-imx8qxp/Makefile b/board/toradex/colibri-imx8qxp/Makefile
new file mode 100644
index 0000000000..db5a718416
--- /dev/null
+++ b/board/toradex/colibri-imx8qxp/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Copyright 2019 Toradex
+#
+
+obj-y += colibri-imx8qxp.o
diff --git a/board/toradex/colibri-imx8qxp/README b/board/toradex/colibri-imx8qxp/README
new file mode 100644
index 0000000000..708bb3e51c
--- /dev/null
+++ b/board/toradex/colibri-imx8qxp/README
@@ -0,0 +1,66 @@
+U-Boot for the Toradex Colibri iMX8QXP V1.0B Module
+
+Quick Start
+===========
+
+- Build the ARM trusted firmware binary
+- Get scfw_tcm.bin and ahab-container.img
+- Build U-Boot
+- Load U-Boot binary using uuu
+- Flash U-Boot binary into the eMMC
+- Boot
+
+Get and Build the ARM Trusted Firmware
+======================================
+
+$ git clone -b imx_4.14.78_1.0.0_ga https://source.codeaurora.org/external/imx/imx-atf
+$ cd imx-atf/
+$ make PLAT=imx8qxp bl31
+
+Get scfw_tcm.bin and ahab-container.img
+=======================================
+
+$ wget https://github.com/toradex/meta-fsl-bsp-release/blob/toradex-sumo-4.14.78-1.0.0_ga-bringup/imx/meta-bsp/recipes-bsp/imx-sc-firmware/files/mx8qx-colibri-scfw-tcm.bin?raw=true
+$ mv mx8qx-colibri-scfw-tcm.bin\?raw\=true mx8qx-colibri-scfw-tcm.bin
+$ wget https://www.nxp.com/lgfiles/NMG/MAD/YOCTO/firmware-imx-8.0.bin
+$ chmod +x firmware-imx-8.0.bin
+$ ./firmware-imx-8.0.bin
+
+Copy the following binaries to the U-Boot folder:
+
+$ cp imx-atf/build/imx8qxp/release/bl31.bin .
+$ cp u-boot/u-boot.bin .
+
+Copy the following firmware to the U-Boot folder:
+
+$ cp firmware-imx-8.0/firmware/seco/ahab-container.img .
+
+Build U-Boot
+============
+
+$ make colibri-imx8qxp_defconfig
+$ make u-boot-dtb.imx
+
+Load the U-Boot Binary Using UUU
+================================
+
+Get the latest version of the universal update utility (uuu) aka mfgtools 3.0:
+
+https://community.nxp.com/external-link.jspa?url=https%3A%2F%2Fgithub.com%2FNXPmicro%2Fmfgtools%2Freleases
+
+Put the module into USB recovery aka serial downloader mode, connect USB device
+to your host and execute uuu:
+
+sudo ./uuu u-boot/u-boot-dtb.imx
+
+Flash the U-Boot Binary into the eMMC
+=====================================
+
+Burn the u-boot-dtb.imx binary to the primary eMMC hardware boot area partition:
+
+load mmc 1:1 $loadaddr u-boot-dtb.imx
+setexpr blkcnt ${filesize} + 0x1ff && setexpr blkcnt ${blkcnt} / 0x200
+mmc dev 0 1
+mmc write ${loadaddr} 0x0 ${blkcnt}
+
+Boot
diff --git a/board/toradex/colibri-imx8qxp/colibri-imx8qxp.c b/board/toradex/colibri-imx8qxp/colibri-imx8qxp.c
new file mode 100644
index 0000000000..aa8eaa0ea1
--- /dev/null
+++ b/board/toradex/colibri-imx8qxp/colibri-imx8qxp.c
@@ -0,0 +1,160 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2019 Toradex
+ */
+
+#include <common.h>
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx8-pins.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sci/sci.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <environment.h>
+#include <errno.h>
+#include <linux/libfdt.h>
+
+#include "../common/tdx-cfg-block.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL	((SC_PAD_CONFIG_OUT_IN << PADRING_CONFIG_SHIFT) | \
+			 (SC_PAD_ISO_OFF << PADRING_LPCONFIG_SHIFT) | \
+			 (SC_PAD_28FDSOI_DSE_DV_HIGH << PADRING_DSE_SHIFT) | \
+			 (SC_PAD_28FDSOI_PS_PU << PADRING_PULL_SHIFT))
+
+static iomux_cfg_t uart3_pads[] = {
+	SC_P_FLEXCAN2_RX | MUX_MODE_ALT(2) | MUX_PAD_CTRL(UART_PAD_CTRL),
+	SC_P_FLEXCAN2_TX | MUX_MODE_ALT(2) | MUX_PAD_CTRL(UART_PAD_CTRL),
+	/* Transceiver FORCEOFF# signal, mux to use pull-up */
+	SC_P_QSPI0B_DQS | MUX_MODE_ALT(4) | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static void setup_iomux_uart(void)
+{
+	imx8_iomux_setup_multiple_pads(uart3_pads, ARRAY_SIZE(uart3_pads));
+}
+
+int board_early_init_f(void)
+{
+	sc_pm_clock_rate_t rate;
+	sc_err_t err = 0;
+
+	/*
+	 * This works around that having only UART3 up the baudrate is 1.2M
+	 * instead of 115.2k. Set UART0 clock root to 80 MHz
+	 */
+	rate = 80000000;
+	err = sc_pm_set_clock_rate(-1, SC_R_UART_0, SC_PM_CLK_PER, &rate);
+	if (err != SC_ERR_NONE)
+		return 0;
+
+	/* Power up UART3 */
+	err = sc_pm_set_resource_power_mode(-1, SC_R_UART_3, SC_PM_PW_MODE_ON);
+	if (err != SC_ERR_NONE)
+		return 0;
+
+	/* Set UART3 clock root to 80 MHz */
+	rate = 80000000;
+	err = sc_pm_set_clock_rate(-1, SC_R_UART_3, SC_PM_CLK_PER, &rate);
+	if (err != SC_ERR_NONE)
+		return 0;
+
+	/* Enable UART3 clock root */
+	err = sc_pm_clock_enable(-1, SC_R_UART_3, SC_PM_CLK_PER, true, false);
+	if (err != SC_ERR_NONE)
+		return 0;
+
+	setup_iomux_uart();
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_DM_GPIO)
+static void board_gpio_init(void)
+{
+	/* TODO */
+}
+#else
+static inline void board_gpio_init(void) {}
+#endif
+
+#if IS_ENABLED(CONFIG_FEC_MXC)
+#include <miiphy.h>
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+void build_info(void)
+{
+	u32 sc_build = 0, sc_commit = 0;
+
+	/* Get SCFW build and commit id */
+	sc_misc_build_info(-1, &sc_build, &sc_commit);
+	if (!sc_build) {
+		printf("SCFW does not support build info\n");
+		sc_commit = 0; /* Display 0 if build info not supported */
+	}
+	printf("Build: SCFW %x\n", sc_commit);
+}
+
+int checkboard(void)
+{
+	puts("Model: Toradex Colibri iMX8X\n");
+
+	build_info();
+	print_bootinfo();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	board_gpio_init();
+
+	return 0;
+}
+
+void detail_board_ddr_info(void)
+{
+	puts("\nDDR    ");
+}
+
+/*
+ * Board specific reset that is system reset.
+ */
+void reset_cpu(ulong addr)
+{
+	/* TODO */
+}
+
+#if defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP)
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	return ft_common_board_setup(blob, bd);
+}
+#endif
+
+int board_mmc_get_env_dev(int devno)
+{
+	return devno;
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+/* TODO move to common */
+	env_set("board_name", "Colibri iMX8QXP");
+	env_set("board_rev", "v1.0");
+#endif
+
+	return 0;
+}
diff --git a/board/toradex/colibri-imx8qxp/imximage.cfg b/board/toradex/colibri-imx8qxp/imximage.cfg
new file mode 100644
index 0000000000..1dcd13271d
--- /dev/null
+++ b/board/toradex/colibri-imx8qxp/imximage.cfg
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2019 Toradex
+ *
+ * Refer doc/README.imx8image for more details about how-to configure
+ * and create imx8image boot image
+ */
+
+#define __ASSEMBLY__
+
+/* Boot from SD, sector size 0x400 */
+BOOT_FROM EMMC_FASTBOOT 0x400
+/* SoC type IMX8QX */
+SOC_TYPE IMX8QX
+/* Append seco container image */
+APPEND mx8qx-ahab-container.img
+/* Create the 2nd container */
+CONTAINER
+/* Add scfw image with exec attribute */
+IMAGE SCU mx8qx-colibri-scfw-tcm.bin
+/* Add ATF image with exec attribute */
+IMAGE A35 bl31.bin 0x80000000
+/* Add U-Boot image with load attribute */
+DATA A35 u-boot-dtb.bin 0x80020000
diff --git a/configs/colibri-imx8qxp_defconfig b/configs/colibri-imx8qxp_defconfig
new file mode 100644
index 0000000000..6dee0be35a
--- /dev/null
+++ b/configs/colibri-imx8qxp_defconfig
@@ -0,0 +1,53 @@
+CONFIG_ARM=y
+CONFIG_ARCH_IMX8=y
+CONFIG_SYS_TEXT_BASE=0x80020000
+CONFIG_SYS_MALLOC_F_LEN=0x4000
+CONFIG_TARGET_COLIBRI_IMX8QXP=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_NR_DRAM_BANKS=3
+CONFIG_FIT=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/toradex/colibri-imx8qxp/imximage.cfg"
+CONFIG_LOG=y
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_BOARDINFO is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_CMD_CPU=y
+# CONFIG_CMD_IMPORTENV is not set
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DM=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_UUID=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_DEFAULT_DEVICE_TREE="fsl-imx8qxp-colibri"
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_CLK_IMX8=y
+CONFIG_CPU=y
+CONFIG_DM_GPIO=y
+CONFIG_MXC_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_IMX_LPI2C=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_PHYLIB=y
+CONFIG_PHY_ADDR_ENABLE=y
+CONFIG_PHY_MICREL=y
+CONFIG_DM_ETH=y
+CONFIG_FEC_MXC_SHARE_MDIO=y
+CONFIG_FEC_MXC_MDIO_BASE=0x5B040000
+CONFIG_FEC_MXC=y
+CONFIG_MII=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_IMX8=y
+CONFIG_POWER_DOMAIN=y
+CONFIG_IMX8_POWER_DOMAIN=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_SERIAL=y
+CONFIG_FSL_LPUART=y
+CONFIG_DM_THERMAL=y
+# CONFIG_EFI_LOADER is not set
diff --git a/include/configs/colibri-imx8qxp.h b/include/configs/colibri-imx8qxp.h
new file mode 100644
index 0000000000..1bfeea6ab2
--- /dev/null
+++ b/include/configs/colibri-imx8qxp.h
@@ -0,0 +1,210 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2019 Toradex
+ */
+
+#ifndef __COLIBRI_IMX8QXP_H
+#define __COLIBRI_IMX8QXP_H
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+
+#define CONFIG_REMAKE_ELF
+
+#define CONFIG_DISPLAY_BOARDINFO_LATE
+
+#undef CONFIG_CMD_EXPORTENV
+#undef CONFIG_CMD_IMPORTENV
+#undef CONFIG_CMD_IMLS
+
+#undef CONFIG_CMD_CRC32
+#undef CONFIG_BOOTM_NETBSD
+
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+#define USDHC1_BASE_ADDR		0x5B010000
+#define USDHC2_BASE_ADDR		0x5B020000
+#define CONFIG_SUPPORT_EMMC_BOOT	/* eMMC specific */
+
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+
+/* Networking */
+#define FEC_QUIRK_ENET_MAC
+
+#define CONFIG_IP_DEFRAG
+#define CONFIG_TFTP_BLOCKSIZE		SZ_4K
+#define CONFIG_TFTP_TSIZE
+
+#define CONFIG_IPADDR			192.168.10.2
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_SERVERIP			192.168.10.1
+
+#define MEM_LAYOUT_ENV_SETTINGS \
+	"fdt_addr_r=0x84000000\0" \
+	"kernel_addr_r=0x82000000\0" \
+	"ramdisk_addr_r=0x84100000\0"
+
+#ifdef CONFIG_AHAB_BOOT
+#define AHAB_ENV "sec_boot=yes\0"
+#else
+#define AHAB_ENV "sec_boot=no\0"
+#endif
+
+/* Boot M4 */
+#define M4_BOOT_ENV \
+	"m4_0_image=m4_0.bin\0" \
+	"loadm4image_0=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} " \
+		"${m4_0_image}\0" \
+	"m4boot_0=run loadm4image_0; dcache flush; bootaux ${loadaddr} 0\0" \
+
+#define MFG_NAND_PARTITION ""
+
+#define BOOT_TARGET_DEVICES(func) \
+	func(MMC, mmc, 0) \
+	func(MMC, mmc, 1) \
+	func(DHCP, dhcp, na)
+#include <config_distro_bootcmd.h>
+#undef BOOTENV_RUN_NET_USB_START
+#define BOOTENV_RUN_NET_USB_START ""
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc g_mass_storage.stall=0 " \
+		"g_mass_storage.removable=1 g_mass_storage.idVendor=0x066F " \
+		"g_mass_storage.idProduct=0x37FF " \
+		"g_mass_storage.iSerialNumber=\"\" " MFG_NAND_PARTITION \
+		"${vidargs} clk_ignore_unused\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;booti ${loadaddr} ${initrd_addr} " \
+		"${fdt_addr};\0" \
+
+/* Initial environment variables */
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	AHAB_ENV \
+	BOOTENV \
+	CONFIG_MFG_ENV_SETTINGS \
+	M4_BOOT_ENV \
+	MEM_LAYOUT_ENV_SETTINGS \
+	"boot_fdt=try\0" \
+	"bootscript=echo Running bootscript from mmc ...; source\0" \
+	"console=ttyLP3 earlycon\0" \
+	"fdt_addr=0x83000000\0"	\
+	"fdt_file=fsl-imx8qxp-colibri-dsihdmi-eval-v3.dtb\0" \
+	"fdt_high=0xffffffffffffffff\0"	\
+	"finduuid=part uuid mmc ${mmcdev}:2 uuid\0" \
+	"image=Image\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffffffffffff\0" \
+	"loadbootscript=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} " \
+		"${script};\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=PARTUUID=${uuid} rootwait " \
+	"mmcautodetect=yes\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run finduuid; run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"booti ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"echo WARN: Cannot load the DT; " \
+			"fi; " \
+		"else " \
+			"echo wait for boot; " \
+		"fi;\0" \
+	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp " \
+		"${vidargs}\0" \
+	"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${loadaddr} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"booti ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"echo WARN: Cannot load the DT; " \
+			"fi; " \
+		"else " \
+			"booti; " \
+		"fi;\0" \
+	"nfsboot=run netargs; dhcp ${loadaddr} ${image}; tftp ${fdt_addr} " \
+		"colibri-imx8qxp/${fdt_file}; booti ${loadaddr} - " \
+		"${fdt_addr}\0" \
+	"panel=NULL\0" \
+	"script=boot.scr\0" \
+	"vidargs=video=imxdpufb5:off video=imxdpufb6:off video=imxdpufb7:off\0"
+
+#undef CONFIG_BOOTCOMMAND
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else booti ${loadaddr} - ${fdt_addr}; fi"
+
+/* Link Definitions */
+#define CONFIG_LOADADDR			0x80280000
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+
+#define CONFIG_SYS_INIT_SP_ADDR		0x80200000
+
+#define CONFIG_SYS_MEMTEST_START	0x88000000
+#define CONFIG_SYS_MEMTEST_END		0x89000000
+
+/* Environment in eMMC, before config block at the end of 1st "boot sector" */
+#define CONFIG_ENV_SIZE			SZ_8K
+#define CONFIG_ENV_OFFSET		(-CONFIG_ENV_SIZE + \
+					 CONFIG_TDX_CFG_BLOCK_OFFSET)
+#define CONFIG_SYS_MMC_ENV_DEV		0	/* USDHC1 eMMC */
+#define CONFIG_SYS_MMC_ENV_PART		1
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+
+/* On Colibri iMX8X USDHC1 is eMMC, USDHC2 is 4-bit SD */
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		((CONFIG_ENV_SIZE + (32 * 1024)) * 1024)
+
+#define CONFIG_SYS_SDRAM_BASE		0x80000000
+#define PHYS_SDRAM_1			0x80000000
+#define PHYS_SDRAM_2			0x880000000
+#define PHYS_SDRAM_1_SIZE		SZ_2G		/* 2 GB */
+#define PHYS_SDRAM_2_SIZE		0x00000000	/* 0 GB */
+
+/* Serial */
+#define CONFIG_BAUDRATE			115200
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_CBSIZE		SZ_2K
+#define CONFIG_SYS_MAXARGS		64
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		8000000	/* 8MHz */
+
+#define BOOTAUX_RESERVED_MEM_BASE 0x88000000
+#define BOOTAUX_RESERVED_MEM_SIZE SZ_128M /* Reserve from second 128MB */
+
+#endif /* __COLIBRI_IMX8QXP_H */
-- 
2.14.5

